<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/strongloop/strong-supervisor"

    >strong-supervisor (v6.1.1)</a>
</h1>
<h4>supervisor and monitor for node.js applications</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor">module strong-supervisor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.dashboard">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>dashboard
            <span class="apidocSignatureSpan">(uri, appmetrics, dashboard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.logger">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>logger
            <span class="apidocSignatureSpan">(sink)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.pidfile">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>pidfile
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.start_command">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>start_command
            <span class="apidocSignatureSpan">(pwd, argv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.tracer">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>tracer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>__module</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>adapter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>app</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>capabilities</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>errors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>expander</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>logger.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>runctl</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.</span>watcher</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.adapter">module strong-supervisor.adapter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.adapter.lrtime">
            function <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>lrtime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.adapter.profile">
            function <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>profile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.adapter.start">
            function <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.adapter.use">
            function <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>use
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>_eventsCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>_events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>domain</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>dyninst</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>internal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>metrics</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.app">module strong-supervisor.app</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.app.host">
            function <span class="apidocSignatureSpan">strong-supervisor.app.</span>host
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.app.name">
            function <span class="apidocSignatureSpan">strong-supervisor.app.</span>name
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.capabilities">module strong-supervisor.capabilities</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.capabilities.list">
            function <span class="apidocSignatureSpan">strong-supervisor.capabilities.</span>list
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.capabilities.query">
            function <span class="apidocSignatureSpan">strong-supervisor.capabilities.</span>query
            <span class="apidocSignatureSpan">(featureName, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.config">module strong-supervisor.config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">strong-supervisor.config.</span>isMaster</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">strong-supervisor.config.</span>isWorker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">strong-supervisor.config.</span>profile</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.config.sendMetrics">
            function <span class="apidocSignatureSpan">strong-supervisor.config.</span>sendMetrics
            <span class="apidocSignatureSpan">(parentCtl, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.config.start">
            function <span class="apidocSignatureSpan">strong-supervisor.config.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.config.watcher">
            function <span class="apidocSignatureSpan">strong-supervisor.config.</span>watcher
            <span class="apidocSignatureSpan">(parentCtl)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">strong-supervisor.config.</span>size</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.config.</span>logger</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.dashboard">module strong-supervisor.dashboard</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.dashboard.dashboard">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>dashboard
            <span class="apidocSignatureSpan">(uri, appmetrics, dashboard)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.dashboard._parse">
            function <span class="apidocSignatureSpan">strong-supervisor.dashboard.</span>_parse
            <span class="apidocSignatureSpan">(uri)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.errors">module strong-supervisor.errors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.errors.ExitError">
            function <span class="apidocSignatureSpan">strong-supervisor.errors.</span>ExitError
            <span class="apidocSignatureSpan">(message, code)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.expander">module strong-supervisor.expander</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.expander.expand">
            function <span class="apidocSignatureSpan">strong-supervisor.expander.</span>expand
            <span class="apidocSignatureSpan">(str, worker)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.logger">module strong-supervisor.logger</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.logger.logger">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>logger
            <span class="apidocSignatureSpan">(sink)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.logger.prototype">module strong-supervisor.logger.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.logger.prototype.error">
            function <span class="apidocSignatureSpan">strong-supervisor.logger.prototype.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.logger.prototype.info">
            function <span class="apidocSignatureSpan">strong-supervisor.logger.prototype.</span>info
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.logger.prototype.log">
            function <span class="apidocSignatureSpan">strong-supervisor.logger.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.logger.prototype.warn">
            function <span class="apidocSignatureSpan">strong-supervisor.logger.prototype.</span>warn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.options">module strong-supervisor.options</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.options.parse">
            function <span class="apidocSignatureSpan">strong-supervisor.options.</span>parse
            <span class="apidocSignatureSpan">(argv)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">strong-supervisor.options.</span>HELP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">strong-supervisor.options.</span>NAME</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.pidfile">module strong-supervisor.pidfile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.pidfile.pidfile">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>pidfile
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.pidfile.create">
            function <span class="apidocSignatureSpan">strong-supervisor.pidfile.</span>create
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.pidfile.exists">
            function <span class="apidocSignatureSpan">strong-supervisor.pidfile.</span>exists
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.runctl">module strong-supervisor.runctl</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.runctl.notifyStarted">
            function <span class="apidocSignatureSpan">strong-supervisor.runctl.</span>notifyStarted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.runctl.onRequest">
            function <span class="apidocSignatureSpan">strong-supervisor.runctl.</span>onRequest
            <span class="apidocSignatureSpan">(req, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.runctl.start">
            function <span class="apidocSignatureSpan">strong-supervisor.runctl.</span>start
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.runctl.</span>parentCtl</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.start_command">module strong-supervisor.start_command</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.start_command.start_command">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>start_command
            <span class="apidocSignatureSpan">(pwd, argv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.start_command.fromStart">
            function <span class="apidocSignatureSpan">strong-supervisor.start_command.</span>fromStart
            <span class="apidocSignatureSpan">(cwd, script)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.start_command.resolveDir">
            function <span class="apidocSignatureSpan">strong-supervisor.start_command.</span>resolveDir
            <span class="apidocSignatureSpan">(cwd, dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.start_command.resolvePackageFromPath">
            function <span class="apidocSignatureSpan">strong-supervisor.start_command.</span>resolvePackageFromPath
            <span class="apidocSignatureSpan">(cwd, relative)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.start_command.resolvePath">
            function <span class="apidocSignatureSpan">strong-supervisor.start_command.</span>resolvePath
            <span class="apidocSignatureSpan">(cwd, script)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.tracer">module strong-supervisor.tracer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.tracer.tracer">
            function <span class="apidocSignatureSpan">strong-supervisor.</span>tracer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.tracer.start">
            function <span class="apidocSignatureSpan">strong-supervisor.tracer.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.strong-supervisor.watcher">module strong-supervisor.watcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.strong-supervisor.watcher.start">
            function <span class="apidocSignatureSpan">strong-supervisor.watcher.</span>start
            <span class="apidocSignatureSpan">(parentCtl, cluster, clusterControl, config)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">strong-supervisor.watcher.</span>_watchers</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor" id="apidoc.module.strong-supervisor">module strong-supervisor</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.dashboard" id="apidoc.element.strong-supervisor.dashboard">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>dashboard
        <span class="apidocSignatureSpan">(uri, appmetrics, dashboard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dashboard(uri, appmetrics, dashboard) {
  var options = {
    appmetrics: appmetrics,
    users: {},
  };
  util._extend(options, parse(uri));

  if (!options.path)
    return {};

  // appmetrics-dash calls the path &#x27;url&#x27; XXX(sam) maybe it should not?
  options.url = options.path;

  options.docs = process.env.STRONGLOOP_DASHBOARD_DOCS;
  options.title = process.env.STRONGLOOP_DASHBOARD_TITLE;

  dashboard.attach(options);

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.logger" id="apidoc.element.strong-supervisor.logger">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>logger
        <span class="apidocSignatureSpan">(sink)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Logger(sink) {
  if (!(this instanceof Logger)) return new Logger(sink);

  this.sink = sink;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.pidfile" id="apidoc.element.strong-supervisor.pidfile">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>pidfile
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(file) {
  if (isStale(file)) {
    unlink(file);
  }
  write(file, process.pid);

  process.on(&#x27;exit&#x27;, unlink.bind(null, file));

  // We don&#x27;t unlink on SIGINT or SIGTERM, because those could be handled and
  // recovered from, &#x27;exit&#x27; is absolutely final.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.start_command" id="apidoc.element.strong-supervisor.start_command">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>start_command
        <span class="apidocSignatureSpan">(pwd, argv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveArgs(pwd, argv) {
  var replacer = symlinkReplacer(pwd);
  var cwd = fs.realpathSync(pwd);
  var script = argv[2] || &#x27;.&#x27;;
  debug(&#x27;resolving CWD: %j, path: %j&#x27;, cwd, script);
  var app = resolvePath(cwd, script);
  var stat = app.stat;
  if (app.error) {
    return app;
  }

  if (stat.isFile()) {
    // given path was either foo/app.js that exists or foo/app that doesn&#x27;t
    // exist but which node would treat ass foo/app.js, so we&#x27;ll just find the
    // the package&#x27;s root directory and use that as the CWD when running the
    // specified script.
    return replacer(resolvePackageFromPath(app.cwd, app.path));
  }

  if (stat.isDirectory()) {
    // The given path is a directory, so now we want to find the nearest
    // package.json, use it as the CWD, and then perform an `npm start` like
    // script resolution.
    var absolutePath = path.resolve(app.cwd, app.path);
    var pkgApp = resolvePackageFromPath(absolutePath);

    // 1. try parsing scripts.start from the package.json
    var pkgStart = resolvePackageStart(pkgApp.cwd);
    if (!pkgStart.error) {
      return replacer(pkgStart);
    }

    // 2. try server.js, app.js, index.js**, then default module resolution
    // ** We explicitly check for index.js even though it will be checked by
    //    the node module resolver because we prefer it over the package&#x27;s main
    //    in cases where they are different.
    pkgApp.path = ifExists(pkgApp.cwd, &#x27;server.js&#x27;) ||
                  ifExists(pkgApp.cwd, &#x27;app.js&#x27;) ||
                  ifExists(pkgApp.cwd, &#x27;index.js&#x27;) ||
                  requireable(pkgApp.cwd, pkgApp.path);
    if (pkgApp.path) {
      return replacer(pkgApp);
    }
  }

  // The package.json doesn&#x27;t say how to run it, and node can&#x27;t decide.. time
  // to error out and let the user know they need to be more specific.
  return {error: Error(&#x27;app is not a file or a directory &#x27;)};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.tracer" id="apidoc.element.strong-supervisor.tracer">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>tracer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tracer() {
  return TRACER;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.adapter" id="apidoc.module.strong-supervisor.adapter">module strong-supervisor.adapter</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.adapter.lrtime" id="apidoc.element.strong-supervisor.adapter.lrtime">
        function <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>lrtime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lrtime() {
  start();
  return appmetrics.lrtime();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Update other values accordingly
  metrics.runningTotal += value;
  metrics.count++;
}

function lrtime() {
  start();
  return appmetrics.<span class="apidocCodeKeywordSpan">lrtime</span>();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.adapter.profile" id="apidoc.element.strong-supervisor.adapter.profile">
        function <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>profile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function profile() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.adapter.start" id="apidoc.element.strong-supervisor.adapter.start">
        function <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start(options) {
  options = util._extend({}, options);

  if (!appmetricsStarted) {
    appmetrics = require(&#x27;appmetrics&#x27;);
    appmetrics.configure(options); // FIXME are the options in agentOptions OK?
    // FIXME confirm appmetrics.configure() accepts sl-run:agentOptions
    appmetrics.enable(&#x27;eventloop&#x27;);
    monitor = appmetrics.monitor();
    initialise();
    appmetricsStarted = true;

    global.APPMETRICS = appmetrics;

    var dash = dashboard(options.dashboard, appmetrics,
                         require(&#x27;appmetrics-dash&#x27;));

    if (dash.path)
      console.log(&#x27;strong-supervisor attaching dashboard at %s&#x27;, dash.path);

    // XXX(sam) Unimplemented features?
    // - watchdogActivationCount
    // - express:usage-record

    exports.on(&#x27;newListener&#x27;, function(type) {
      switch (type) {
        case &#x27;express:usage-record&#x27;:
          // turn on express usage record
          monitor.on(&#x27;express:usage-record&#x27;, function(record) {
            exports.emit(&#x27;express:usage-record&#x27;, record);
          });
          break;
      }
    });

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var logger = new Logger(process.stderr);

// Attach targeted control listener to cluster, for both master and workers.
require(&#x27;./targetctl&#x27;);

// Wrap watcher start, for use in master and workers.
function watcherStart(parentCtl) {
watcher.<span class="apidocCodeKeywordSpan">start</span>(parentCtl, cluster, control, module.exports);
}

if (cluster.isWorker) {
module.exports = {
  isWorker: true,
  isMaster: false,
  logger: logger,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.adapter.use" id="apidoc.element.strong-supervisor.adapter.use">
        function <span class="apidocSignatureSpan">strong-supervisor.adapter.</span>use
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(callback) {

  // The callback needs to fire every 60 seconds with data from the last 60
  // seconds
  setInterval(function() {
    // Get data from last 60 seconds
    var eventLoopData = getEventLoopData();
    var cpuData = getCpuData();
    var httpData = getHttpData();
    var heapData = getHeapData();
    var usedHeap = getGcHeapData();
    var messageData = getMessageData();

    debug(&#x27;eventLoopData: %j&#x27;, eventLoopData);

    if (eventLoopData.count &#x3e; 0) {
      // This function can run before data collection has started, in which case
      // there is no data, and min/max/average are undefined. Skip reporting
      // until data arrives.
      callback(&#x27;loop.count&#x27;, assertPositive(eventLoopData.count));
      callback(&#x27;loop.minimum&#x27;, assertPositive(eventLoopData.minimum));
      callback(&#x27;loop.maximum&#x27;, assertPositive(eventLoopData.maximum));
      callback(&#x27;loop.average&#x27;, assertPositive(eventLoopData.average));
    }

    debug(&#x27;cpuData: %j&#x27;, cpuData);

    if (cpuData.count) {
      // This function can run before any CPU data has been collected. Avoid
      // reporting unknown or invalid values by just not reporting if there
      // is no data.
      callback(&#x27;cpu.system&#x27;, assertPositive(cpuData.system));
      callback(&#x27;cpu.total&#x27;, assertPositive(cpuData.total));
      callback(&#x27;cpu.user&#x27;, assertPositive(cpuData.user));
    }

    callback(&#x27;http.connection.count&#x27;, assertPositive(httpData.count));

    // Callback with probe data of each probe if there have been events
    var probeData;

    for (var i in probeList) {
      if (probeMetrics[probeList[i]]) {
        probeData = getProbeData(probeList[i]);
        callback(probeList[i] + &#x27;.count&#x27;, assertPositive(probeData.count));
        callback(probeList[i] + &#x27;.average&#x27;, assertPositive(probeData.average));
        callback(probeList[i] + &#x27;.minimum&#x27;, assertPositive(probeData.minimum));
        callback(probeList[i] + &#x27;.maximum&#x27;, assertPositive(probeData.maximum));
      }
    }

    if (usedHeap &#x3e; 0) {
      callback(&#x27;gc.heap.used&#x27;, usedHeap);
    }

    if (heapData.total &#x26;&#x26; heapData.used) {
      callback(&#x27;heap.total&#x27;, assertPositive(heapData.total));
      callback(&#x27;heap.used&#x27;, assertPositive(heapData.used));
    }

    if (messageData.sent &#x3e; 0 || messageData.received &#x3e; 0) {
      callback(&#x27;messages.out.count&#x27;, messageData.sent);
      callback(&#x27;messages.in.count&#x27;, messageData.received);
    }

  }, callbackInterval).unref();

  setInterval(function() {
    var version = process.version.split(&#x27;v&#x27;)[1];
    if (objectTrackingEnabled) {
      if (version &#x3e;= &#x27;0.11&#x27;) {
        var histogram = appmetrics.getObjectHistogram();
        require(&#x27;fs&#x27;).writeFileSync(&#x27;histogram-&#x27; + Date.now() + &#x27;.json&#x27;,
                                    JSON.stringify(histogram));
        var objectCounts = compareHistograms(lastObjectHistogram, histogram);
        lastObjectHistogram = histogram;
        // Get object stats
        for (var type in objectCounts) {
          var tuple = objectCounts[type];
          // Don&#x27;t output events for no change?
          // XXX(toby) - What&#x27;s the correct behaviour here?
          // XXX(toby) - Should we skip &#x22;weird&#x22; object types?
          // FIXME(toby) I&#x27;ll have to read the strong-agent code to see how what
          // you are doing is different, but if you look at histogram.json I
          // checked in, you&#x27;ll see many of the types are pure garbage. I wonder
          // if non-string things like functions are being coerced into strings?
          // The entire source code of files is showing up as &#x27;types&#x27;!
          if (type.indexOf(&#x27;\n&#x27;) &#x3e;= 0) {
            console.trace(&#x27;%j&#x27;, type);
            console.assert(type.indexOf(&#x27;\n&#x27;) &#x3c; 0, &#x27;INVALID&#x27;);
          } else {
            if (tuple.count !== 0 &#x26;&#x26; tuple.size !== 0) {
              callback(&#x27;object.&#x27; + type + &#x27;.count&#x27;, tuple.count);
              callback(&#x27;object.&#x27; + type + &#x27;.size&#x27;, tuple.size);
            }
          }
        }
      } else {
        callback(&#x27;Warning&#x27;,
                 &#x27;Object tracking is not supported on node v&#x27; + version);
      }
    } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  server.on(&#x27;metrics&#x27;, forwardMetrics);
}

server.start(function(er) {
  assert.ifError(er);

  process.env.STRONGLOOP_METRICS = server.url;
  agent().<span class="apidocCodeKeywordSpan">use</span>(function(name, value) {
    server.send(name, value);
  });
  return callback(server);
});

if (this.setupChildLogger &#x26;&#x26; server.child) {
  var statsdWorker = {
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.app" id="apidoc.module.strong-supervisor.app">module strong-supervisor.app</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.app.host" id="apidoc.element.strong-supervisor.app.host">
        function <span class="apidocSignatureSpan">strong-supervisor.app.</span>host
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function host() {
  var host = os.hostname();
  // XXX strip domain from host for uniformity?
  return host;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.setupChildLogger(statsdWorker);
}

function expandScope(scope) {
  return expandString(scope, {
    id: (cluster.worker &#x26;&#x26; cluster.worker.id) | 0,
    pid: process.pid,
    hostname: app.<span class="apidocCodeKeywordSpan">host</span>(),
    appName: app.name(),
  });
}

function forwardMetrics(metrics) {
  debug(&#x27;received: %j&#x27;, metrics);
  parentCtl.notify({cmd: &#x27;metrics&#x27;, metrics: injectIdentifiers(metrics)});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.app.name" id="apidoc.element.strong-supervisor.app.name">
        function <span class="apidocSignatureSpan">strong-supervisor.app.</span>name
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function name() {
  try {
    return require(path.resolve(&#x27;package.json&#x27;)).name;
  } catch (e) {
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function expandScope(scope) {
  return expandString(scope, {
    id: (cluster.worker &#x26;&#x26; cluster.worker.id) | 0,
    pid: process.pid,
    hostname: app.host(),
    appName: app.<span class="apidocCodeKeywordSpan">name</span>(),
  });
}

function forwardMetrics(metrics) {
  debug(&#x27;received: %j&#x27;, metrics);
  parentCtl.notify({cmd: &#x27;metrics&#x27;, metrics: injectIdentifiers(metrics)});
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.capabilities" id="apidoc.module.strong-supervisor.capabilities">module strong-supervisor.capabilities</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.capabilities.list" id="apidoc.element.strong-supervisor.capabilities.list">
        function <span class="apidocSignatureSpan">strong-supervisor.capabilities.</span>list
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listCapabilities() {
  return Object.keys(capabilities);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function queryCapabilities(req, rsp, callback) {
var features = req.feature;
var support = rsp.capabilities = {};

if (typeof features === &#x27;string&#x27;) {
  features = features.split(&#x27;,&#x27;);
} else {
  features = capabilities.<span class="apidocCodeKeywordSpan">list</span>();
}

async.map(features, function(feature, callback) {
  capabilities.query(feature, function(status, reasons) {
    support[feature] = {
      status: status,
      reasons: reasons
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.capabilities.query" id="apidoc.element.strong-supervisor.capabilities.query">
        function <span class="apidocSignatureSpan">strong-supervisor.capabilities.</span>query
        <span class="apidocSignatureSpan">(featureName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queryCapabilities(featureName, callback) {
  var feature = capabilities[featureName];

  if (feature == null) {
    callback(false, [&#x27;Unknown capability.&#x27;]);
    return;
  }

  var status = true;

  async.map(feature.checks, function(check, callback) {
    check.check(function(result, reason) {
      status = status &#x26;&#x26; result;
      callback(null, reason);
    });
  }, function(err, reasons) {
    if (err) {
      callback(false, [&#x27;Could not verify support.&#x27;]);
      return;
    }

    callback(status, _.compact(reasons));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (typeof features === &#x27;string&#x27;) {
features = features.split(&#x27;,&#x27;);
  } else {
features = capabilities.list();
  }

  async.map(features, function(feature, callback) {
capabilities.<span class="apidocCodeKeywordSpan">query</span>(feature, function(status, reasons) {
  support[feature] = {
    status: status,
    reasons: reasons
  };

  callback(null, support[feature]);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.config" id="apidoc.module.strong-supervisor.config">module strong-supervisor.config</a></h1>








    <h2>
        <a href="#apidoc.element.strong-supervisor.config.sendMetrics" id="apidoc.element.strong-supervisor.config.sendMetrics">
        function <span class="apidocSignatureSpan">strong-supervisor.config.</span>sendMetrics
        <span class="apidocSignatureSpan">(parentCtl, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sendMetrics(parentCtl, callback) {
  callback = callback || function() {};

  // Scenarios:
  //   no STRONGLOOP_METRICS, return
  //
  //   called from master:
  //     needs to .start() with expanded scope
  //       if invalid, warn, and clear env... so children don&#x27;t warn
  //     needs to wait for start
  //     needs to reset STRONGLOOP_METRICS *before* starting cluster
  //       statsd://:PORT/SCOPE-TEMPLATE
  //
  //
  //   called from worker:
  //     needs to .start() with expanded scope (will always be a statsd: URL)
  //
  //   called from single-instance:
  //     needs to .start() with expanded scope (can reset env, its ok)

  var self = this;
  var endpoints = parse(process.env.STRONGLOOP_METRICS);

  function parse(url) {
    if (url == null)
      return [];
    try {
      return JSON.parse(url);
    } catch (er) {
      return [url];
    }
  }

  if (cluster.isMaster) {
    endpoints.push(&#x27;internal:&#x27;);
  }

  if (!endpoints.length) {
    process.nextTick(callback);
    return false;
  }

  var server = Statsd({
    scope: &#x27;%a.%h.%w&#x27;,
    expandScope: expandScope,
    flushInterval: process.env.STRONGLOOP_FLUSH_INTERVAL,
    syslog: syslog,
  });

  debug(&#x27;metrics endpoints: %j&#x27;, endpoints);

  endpoints.forEach(function(endpoint) {
    try {
      server.backend(endpoint);
      if (cluster.isMaster) {
        self.logger.info(&#x27;supervisor reporting metrics to `%s`&#x27;, endpoint);
      }
    } catch (er) {
      console.error(&#x27;Invalid metrics endpoint `%s`: %s&#x27;, endpoint, er.message);
      process.exit(1);
    }
  });

  // Internal metrics support, forwarded over node ipc from cluster master
  // to parent.
  if (parentCtl) {
    server.on(&#x27;metrics&#x27;, forwardMetrics);
  }

  server.start(function(er) {
    assert.ifError(er);

    process.env.STRONGLOOP_METRICS = server.url;
    agent().use(function(name, value) {
      server.send(name, value);
    });
    return callback(server);
  });

  if (this.setupChildLogger &#x26;&#x26; server.child) {
    var statsdWorker = {
      process: {
        stdout: server.child.stdout,
        stderr: server.child.stderr,
        pid: process.pid,
      },
      id: &#x27;statsd&#x27;,
    };
    this.setupChildLogger(statsdWorker);
  }

  function expandScope(scope) {
    return expandString(scope, {
      id: (cluster.worker &#x26;&#x26; cluster.worker.id) | 0,
      pid: process.pid,
      hostname: app.host(),
      appName: app.name(),
    });
  }

  function forwardMetrics(metrics) {
    debug(&#x27;received: %j&#x27;, metrics);
    parentCtl.notify({cmd: &#x27;metrics&#x27;, metrics: injectIdentifiers(metrics)});
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        cluster.workers[id].logFile.reOpen();
      }
    }
    logger.info(&#x27;log files reopened&#x27;);
  });
}

this.<span class="apidocCodeKeywordSpan">sendMetrics</span>(runctl.parentCtl, function() {
  // Wait until metrics has started before starting cluster control, because
  // the workers need to know what ephemeral port the statsd server is
  // listening on in order to send it metrics.
  // XXX(sam) above should no longer be true, since we use node ipc to
  // send metrics, not an ephemeral port. side effect of the delay is
  // that the first &#x27;status&#x27; notification occurs before control is started,
  // so the setSize part of strong-cluster-control.status() is not yet set.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.config.start" id="apidoc.element.strong-supervisor.config.start">
        function <span class="apidocSignatureSpan">strong-supervisor.config.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start() {
  config.setupChildLogger = setupChildLogger;

  cluster.on(&#x27;fork&#x27;, setupChildLogger);

  logger.info(&#x27;supervisor starting (pid %d)&#x27;, process.pid);

  if (options.pid) {
    try {
      pidfile.create(options.pid);
    } catch (er) {
      console.error(&#x27;supervisor failed to create pid file: %s&#x27;, er.message);
      process.exit(1);
    }
  }

  // Re-require this so that strong-agent (which may be required by now)
  // notices, and attaches cluster control instrumentation.
  require(&#x27;strong-cluster-control&#x27;);

  control.on(&#x27;start&#x27;, function() {
    runctl.notifyStarted();

    if (!options.channel) return;

    logger.info(&#x27;supervisor listening on \&#x27;%s\&#x27;&#x27;, options.channel);

    runctl.start({
      channel: options.channel,
      logger: logger,
    });
  });
  control.on(&#x27;setSize&#x27;, function() {
    logger.info(&#x27;supervisor size set to&#x27;, this.options.size);
  });
  control.on(&#x27;resize&#x27;, function() {
    logger.info(&#x27;supervisor resized to&#x27;, this.options.size);
  });
  control.on(&#x27;startWorker&#x27;, function(w) {
    logger.info(&#x27;supervisor started worker %d (pid %d)&#x27;, w.id, w.process.pid);
  });
  control.on(&#x27;stopWorker&#x27;, function(w) {
    logger.info(&#x27;supervisor stopped worker %d (pid %d)&#x27;, w.id, w.process.pid);
  });
  control.on(&#x27;stop&#x27;, function() {
    logger.info(&#x27;supervisor stopped&#x27;);
    process.exit(); // XXX should not be necessary!
  });
  cluster.on(&#x27;exit&#x27;, function(worker, code, signal) {
    var exit = worker.suicide ? &#x27;expected&#x27; : &#x27;accidental&#x27;;
    logger.error(&#x27;supervisor worker id %s (pid %d) %s exit with %s&#x27;,
                  worker.id, worker.process.pid, exit, signal || code
                 );
  });

  var lastSignal = null;
  process.on(&#x27;exit&#x27;, function(code) {
    if (code === 0 &#x26;&#x26; lastSignal) {
      process.kill(process.pid, lastSignal);
      return;
    }
    logger.error(&#x27;supervisor exiting with code %d&#x27;, code);
  });

  process.once(&#x27;SIGINT&#x27;, function() {
    logger.warn(&#x27;received SIGINT, shutting down&#x27;);
    lastSignal = &#x27;SIGINT&#x27;;
    control.stop();
  });
  process.once(&#x27;SIGTERM&#x27;, function() {
    logger.warn(&#x27;received SIGTERM, shutting down&#x27;);
    lastSignal = &#x27;SIGTERM&#x27;;
    control.stop();
  });
  process.on(&#x27;SIGHUP&#x27;, function() {
    logger.warn(&#x27;received SIGHUP, restarting workers&#x27;);
    try {
      chdir(process.env.PWD);
    } catch (er) {
      logger.error(&#x27;failed to chdir to \&#x27;%s\&#x27;: %s&#x27;, process.env.PWD, er);
    }
    control.restart();
  });

  if (supervisorLog !== process.stdout) {
    process.on(&#x27;SIGUSR2&#x27;, function() {
      logger.warn(&#x27;received SIGUSR2, re-opening log files&#x27;);
      supervisorLog.reOpen();
      for (var id in cluster.workers) {
        if (cluster.workers[id].logFile !== supervisorLog) {
          cluster.workers[id].logFile.reOpen();
        }
      }
      logger.info(&#x27;log files reopened&#x27;);
    });
  }

  this.sendMetrics(runctl.parentCtl, function() {
    // Wait until metrics has started before starting cluster control, because
    // the workers need to know what ephemeral port the statsd server is
    // listening on in order to send it metrics.
    // XXX(sam) above should no longer be true, since we use node ipc to
    // send metrics, not an ephemeral port. side effect of the delay is
    // that the first &#x27;status&#x27; notification occurs before control is started,
    // so the setSize part of strong-cluster-control.status() is not yet set.
    debug(&#x27;cluster-control size: %j&#x27;, config.size);
    if (config.size &#x3c; 0) {
      // Fork this number of workers... but don&#x27;t restart them. Mostly used
      // as `-1` by arc.
      for (var size = 0; size &#x3e; config.size; size--) {
        cluster.fork();
      }
      delete config.size;
    }
    control.start({size: config.size});
  });

  this.watcher(runctl.parentCtl);

  function setupChildLogger(worker) {
    var tag = {pid: worker.process.pid, worker: worker.id};
    var logStream = isPerWorker
                  ? new LogWriter(worker, options)  // cleaned up by pipe()
                  : supervisorLog;                  // cleaned up by exit()
    var outLog = transformer({
      timeStamp: o ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var logger = new Logger(process.stderr);

// Attach targeted control listener to cluster, for both master and workers.
require(&#x27;./targetctl&#x27;);

// Wrap watcher start, for use in master and workers.
function watcherStart(parentCtl) {
watcher.<span class="apidocCodeKeywordSpan">start</span>(parentCtl, cluster, control, module.exports);
}

if (cluster.isWorker) {
module.exports = {
  isWorker: true,
  isMaster: false,
  logger: logger,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.config.watcher" id="apidoc.element.strong-supervisor.config.watcher">
        function <span class="apidocSignatureSpan">strong-supervisor.config.</span>watcher
        <span class="apidocSignatureSpan">(parentCtl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function watcherStart(parentCtl) {
  watcher.start(parentCtl, cluster, control, module.exports);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      cluster.fork();
    }
    delete config.size;
  }
  control.start({size: config.size});
});

this.<span class="apidocCodeKeywordSpan">watcher</span>(runctl.parentCtl);

function setupChildLogger(worker) {
  var tag = {pid: worker.process.pid, worker: worker.id};
  var logStream = isPerWorker
                ? new LogWriter(worker, options)  // cleaned up by pipe()
                : supervisorLog;                  // cleaned up by exit()
  var outLog = transformer({
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.dashboard" id="apidoc.module.strong-supervisor.dashboard">module strong-supervisor.dashboard</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.dashboard.dashboard" id="apidoc.element.strong-supervisor.dashboard.dashboard">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>dashboard
        <span class="apidocSignatureSpan">(uri, appmetrics, dashboard)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dashboard(uri, appmetrics, dashboard) {
  var options = {
    appmetrics: appmetrics,
    users: {},
  };
  util._extend(options, parse(uri));

  if (!options.path)
    return {};

  // appmetrics-dash calls the path &#x27;url&#x27; XXX(sam) maybe it should not?
  options.url = options.path;

  options.docs = process.env.STRONGLOOP_DASHBOARD_DOCS;
  options.title = process.env.STRONGLOOP_DASHBOARD_TITLE;

  dashboard.attach(options);

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.dashboard._parse" id="apidoc.element.strong-supervisor.dashboard._parse">
        function <span class="apidocSignatureSpan">strong-supervisor.dashboard.</span>_parse
        <span class="apidocSignatureSpan">(uri)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(uri) {
  var options = {};

  if (!uri)
    return options;

  if (uri === &#x27;&#x27;)
    return options;

  if (uri === &#x27;off&#x27;)
    return options;

  if (uri === &#x27;on&#x27;) {
    options.path = &#x27;/appmetrics-dash&#x27;;
    return options;
  }

  uri = url.parse(uri);
  if (uri.pathname === &#x27;/&#x27;)
    delete uri.pathname;

  options.path = uri.pathname || &#x27;/appmetrics-dash&#x27;;

  assign(&#x27;host&#x27;, &#x27;hostname&#x27;);
  assign(&#x27;port&#x27;, &#x27;port&#x27;);

  function assign(to, from) {
    if (uri[from] != null &#x26;&#x26; uri[from] !== &#x27;&#x27;) {
      options[to] = uri[from];
    }
  }

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.errors" id="apidoc.module.strong-supervisor.errors">module strong-supervisor.errors</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.errors.ExitError" id="apidoc.element.strong-supervisor.errors.ExitError">
        function <span class="apidocSignatureSpan">strong-supervisor.errors.</span>ExitError
        <span class="apidocSignatureSpan">(message, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ExitError(message, code) {
  var self = new Error(message);
  self.code = code == null ? 1 : code;
  self.name = &#x27;ExitError&#x27;;
  return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.expander" id="apidoc.module.strong-supervisor.expander">module strong-supervisor.expander</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.expander.expand" id="apidoc.element.strong-supervisor.expander.expand">
        function <span class="apidocSignatureSpan">strong-supervisor.expander.</span>expand
        <span class="apidocSignatureSpan">(str, worker)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expand = function (str, worker) {
  return printfReplacer(str || &#x27;&#x27;, workerParams(worker));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.logger" id="apidoc.module.strong-supervisor.logger">module strong-supervisor.logger</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.logger.logger" id="apidoc.element.strong-supervisor.logger.logger">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>logger
        <span class="apidocSignatureSpan">(sink)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Logger(sink) {
  if (!(this instanceof Logger)) return new Logger(sink);

  this.sink = sink;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.logger.prototype" id="apidoc.module.strong-supervisor.logger.prototype">module strong-supervisor.logger.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.logger.prototype.error" id="apidoc.element.strong-supervisor.logger.prototype.error">
        function <span class="apidocSignatureSpan">strong-supervisor.logger.prototype.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function () {
  var args = firstArgs.concat([].slice.call(arguments));
  return fn.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x27;use strict&#x27;;

// May set options in process.env, so run first.
try {
  var options = require(&#x27;./options&#x27;).parse(process.argv);
} catch (er) {
  if (er.code != null) {
    console.<span class="apidocCodeKeywordSpan">error</span>(&#x27;%s&#x27;, er.message);
    return process.exit(er.code);
  }
  console.error(er.stack);
  return process.exit(1);
}

var Logger = require(&#x27;./logger&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.logger.prototype.info" id="apidoc.element.strong-supervisor.logger.prototype.info">
        function <span class="apidocSignatureSpan">strong-supervisor.logger.prototype.</span>info
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function () {
  var args = firstArgs.concat([].slice.call(arguments));
  return fn.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
logger.sink.pipe(supervisorLog);

config.start = function start() {
config.setupChildLogger = setupChildLogger;

cluster.on(&#x27;fork&#x27;, setupChildLogger);

logger.<span class="apidocCodeKeywordSpan">info</span>(&#x27;supervisor starting (pid %d)&#x27;, process.pid);

if (options.pid) {
  try {
    pidfile.create(options.pid);
  } catch (er) {
    console.error(&#x27;supervisor failed to create pid file: %s&#x27;, er.message);
    process.exit(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.logger.prototype.log" id="apidoc.element.strong-supervisor.logger.prototype.log">
        function <span class="apidocSignatureSpan">strong-supervisor.logger.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
  var args = firstArgs.concat([].slice.call(arguments));
  return fn.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

global.APPMETRICS = appmetrics;

var dash = dashboard(options.dashboard, appmetrics,
                     require(&#x27;appmetrics-dash&#x27;));

if (dash.path)
  console.<span class="apidocCodeKeywordSpan">log</span>(&#x27;strong-supervisor attaching dashboard at %s&#x27;, dash.path);

// XXX(sam) Unimplemented features?
// - watchdogActivationCount
// - express:usage-record

exports.on(&#x27;newListener&#x27;, function(type) {
  switch (type) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.logger.prototype.warn" id="apidoc.element.strong-supervisor.logger.prototype.warn">
        function <span class="apidocSignatureSpan">strong-supervisor.logger.prototype.</span>warn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warn = function () {
  var args = firstArgs.concat([].slice.call(arguments));
  return fn.apply(this, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    process.kill(process.pid, lastSignal);
    return;
  }
  logger.error(&#x27;supervisor exiting with code %d&#x27;, code);
});

process.once(&#x27;SIGINT&#x27;, function() {
  logger.<span class="apidocCodeKeywordSpan">warn</span>(&#x27;received SIGINT, shutting down&#x27;);
  lastSignal = &#x27;SIGINT&#x27;;
  control.stop();
});
process.once(&#x27;SIGTERM&#x27;, function() {
  logger.warn(&#x27;received SIGTERM, shutting down&#x27;);
  lastSignal = &#x27;SIGTERM&#x27;;
  control.stop();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.options" id="apidoc.module.strong-supervisor.options">module strong-supervisor.options</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.options.parse" id="apidoc.element.strong-supervisor.options.parse">
        function <span class="apidocSignatureSpan">strong-supervisor.options.</span>parse
        <span class="apidocSignatureSpan">(argv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(argv) {
  var options = {
    NAME: exports.NAME,
    HELP: exports.HELP,
    argv: argv,         // process.argv stripped of command...
    args: [&#x27;.&#x27;],        // app app-options...
    enableTracing: false,
    profile: true,
    channel: process.env.STRONGLOOP_CONTROL || &#x27;runctl&#x27;,
    log: false,
    metrics: null,
    timeStampWorkerLogs: true,
    timeStampSupervisorLogs: true,
    logDecoration: true,
    syslog: false,
  };
  // cluster_size is for compatibility with strong-cluster-control@1.x
  var cluster = process.env.STRONGLOOP_CLUSTER;
  if (cluster == null || cluster === &#x27;&#x27;) {
    cluster = &#x27;CPU&#x27;;
  }
  for (var i = 2; i &#x3c; argv.length; i++) {
    var option = argv[i];
    if (option === &#x27;-h&#x27;) {
      options.help = true;

    } else if (option === &#x27;--help&#x27;) {
      options.help = true;

    } else if (option === &#x27;-v&#x27;) {
      options.version = true;

    } else if (option === &#x27;--version&#x27;) {
      options.version = true;

    } else if (option === &#x27;--log&#x27; || option === &#x27;-l&#x27;) {
      i++;
      options.log = argv[i];

    } else if (/^--log=/.test(option)) {
      options.log = value(option, options.log);

    } else if (option === &#x27;--syslog&#x27;) {
      options.syslog = syslogAvailable;

    } else if (option === &#x27;--metrics&#x27; || option === &#x27;-m&#x27;) {
      i++;
      options.metrics = options.metrics || [];
      options.metrics.push(argv[i]);
      options.profile = true;

    } else if (/^--metrics=/.test(option)) {
      options.metrics = options.metrics || [];
      options.metrics.push(value(option));
      options.profile = true;

    } else if (option === &#x27;--pid&#x27; || option === &#x27;-p&#x27;) {
      i++;
      options.pid = argv[i];

    } else if (/^--pid=/.test(option)) {
      options.pid = value(option, options.pid);

    } else if (option === &#x27;--profile&#x27;) {
      options.profile = true;

    } else if (option === &#x27;--no-profile&#x27;) {
      options.profile = false;
      options.metrics = null;
      delete process.env.STRONGLOOP_METRICS;

    } else if (option === &#x27;--trace&#x27;) {
      options.enableTracing = true;

    } else if (option === &#x27;--cluster&#x27;) {
      i++;
      cluster = argv[i];

    } else if (/^--cluster=/.test(option)) {
      cluster = value(argv[i], cluster);

    } else if (option === &#x27;--no-cluster&#x27;) {
      cluster = &#x27;no&#x27;;

    // Only -C,--control,--no-control are documented, now, to align with
    // strong-pm. The others are legacy, to be deleted sometime.
    } else if (/^--(control|port|addr|path)$/.test(option)) {
      i++;
      options.channel = argv[i];

    } else if (option === &#x27;-C&#x27;) {
      i++;
      options.channel = argv[i];

    } else if (/^--(control|port|addr|path)=/.test(option)) {
      options.channel = value(option, options.channel);

    } else if (option === &#x27;--no-control&#x27;) {
      options.channel = false;

    } else if (option === &#x27;--no-channel&#x27;) {
      options.channel = false;

    } else if (option === &#x27;--no-timestamp-workers&#x27;) {
      options.timeStampWorkerLogs = false;

    } else if (option === &#x27;--no-timestamp-supervisor&#x27;) {
      options.timeStampSupervisorLogs = false;

    } else if (option === &#x27;--no-log-decoration&#x27;) {
      options.logDecoration = false;

    } else {
      options.argv = argv.slice(0, i);
      options.args = argv.slice(i);
      break;
    }
  }

  if (options.syslog) {
    options.timeStampSupervisorLogs = false;
    options.timeStampWorkerLogs = false;
  }

  if (options.metrics) {
    options.metrics = JSON.stringify(options.metrics);
  }

  options.cluster = {
    isWorker: false,
    isMaster: true,
  };

  if (/cpu/i.test(cluster)) {
    // --cluster=cpu, --cluster=CPUs
    options.cluster.size = os.cpus().length;
  } else if (/^-?[0-9]+$/.test(cluster)) {
    // --cluster=[-]N, N is 0, 1, ...
    options.cluster.size = +cluster;
  } else {
    throw new ExitError(fmt(&#x27;Invalid cluster option: %s&#x27;, cluster));
  }
  var protocol;
  // The protocol includes the colon on parsing!
  var protocolMap = {
    &#x27;http:&#x27;: &#x27;http&#x27;,
    &#x27;https:&#x27;: &#x27;http&#x27;,
    &#x27;ws:&#x27;: &#x27;ws&#x27;,
    &#x27;wss:&#x27;: &#x27;wss&#x27;,
    // Default will be &#x27;ws&#x27;
  };
  if (options. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// changed for reasons of backwards compatibility.
/*eslint camelcase:0*/

&#x27;use strict&#x27;;

// May set options in process.env, so run first.
try {
var options = require(&#x27;./options&#x27;).<span class="apidocCodeKeywordSpan">parse</span>(process.argv);
} catch (er) {
if (er.code != null) {
  console.error(&#x27;%s&#x27;, er.message);
  return process.exit(er.code);
}
console.error(er.stack);
return process.exit(1);
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.pidfile" id="apidoc.module.strong-supervisor.pidfile">module strong-supervisor.pidfile</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.pidfile.pidfile" id="apidoc.element.strong-supervisor.pidfile.pidfile">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>pidfile
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(file) {
  if (isStale(file)) {
    unlink(file);
  }
  write(file, process.pid);

  process.on(&#x27;exit&#x27;, unlink.bind(null, file));

  // We don&#x27;t unlink on SIGINT or SIGTERM, because those could be handled and
  // recovered from, &#x27;exit&#x27; is absolutely final.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.pidfile.create" id="apidoc.element.strong-supervisor.pidfile.create">
        function <span class="apidocSignatureSpan">strong-supervisor.pidfile.</span>create
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(file) {
  if (isStale(file)) {
    unlink(file);
  }
  write(file, process.pid);

  process.on(&#x27;exit&#x27;, unlink.bind(null, file));

  // We don&#x27;t unlink on SIGINT or SIGTERM, because those could be handled and
  // recovered from, &#x27;exit&#x27; is absolutely final.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

cluster.on(&#x27;fork&#x27;, setupChildLogger);

logger.info(&#x27;supervisor starting (pid %d)&#x27;, process.pid);

if (options.pid) {
  try {
    pidfile.<span class="apidocCodeKeywordSpan">create</span>(options.pid);
  } catch (er) {
    console.error(&#x27;supervisor failed to create pid file: %s&#x27;, er.message);
    process.exit(1);
  }
}

// Re-require this so that strong-agent (which may be required by now)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.pidfile.exists" id="apidoc.element.strong-supervisor.pidfile.exists">
        function <span class="apidocSignatureSpan">strong-supervisor.pidfile.</span>exists
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exists(file) {
  return !isStale(file);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.runctl" id="apidoc.module.strong-supervisor.runctl">module strong-supervisor.runctl</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.runctl.notifyStarted" id="apidoc.element.strong-supervisor.runctl.notifyStarted">
        function <span class="apidocSignatureSpan">strong-supervisor.runctl.</span>notifyStarted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifyStarted = function () {
  // Must not be done synchronously in the require, we don&#x27;t know the app name
  // until after run has found the app, and change to its directory.
  ctlChannel.notify({
    wid: 0,
    cmd: &#x27;started&#x27;,
    pid: process.pid,
    ppid: 0,  // Value is not known for the master process
    pst: master.startTime,
    appName: app.name(),
    agentVersion: agentVersion,
    debuggerVersion: debuggerVersion,
    nodeVersion: process.version,
    osVersion: osVersion,
    setSize: master.size,
  });

  // Status notifications usually come after every fork and exit, but if there
  // are no forks, we still want at least one status notification sent. Note
  // that size may be undefined, which isn&#x27;t &#x3e; or &#x3c; than 1.
  if (!(master.options.size &#x3e;= 1)) {
    notifyStatus();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // Re-require this so that strong-agent (which may be required by now)
  // notices, and attaches cluster control instrumentation.
  require(&#x27;strong-cluster-control&#x27;);

  control.on(&#x27;start&#x27;, function() {
runctl.<span class="apidocCodeKeywordSpan">notifyStarted</span>();

if (!options.channel) return;

logger.info(&#x27;supervisor listening on \&#x27;%s\&#x27;&#x27;, options.channel);

runctl.start({
  channel: options.channel,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.runctl.onRequest" id="apidoc.element.strong-supervisor.runctl.onRequest">
        function <span class="apidocSignatureSpan">strong-supervisor.runctl.</span>onRequest
        <span class="apidocSignatureSpan">(req, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onRequest(req, callback) {
<span class="apidocCodeCommentSpan">  /* eslint no-redeclare:0 */
</span>  debug(&#x27;request %s&#x27;, debug.json(req));

  var cmd = req.cmd;
  var rsp = {
  };

  if (cmd === &#x27;status&#x27;) {
    rsp = clusterStatus();
  } else if (cmd === &#x27;npm-ls&#x27;) {
    rsp = null;
    npmls.read(&#x27;.&#x27;, function(er, data) {
      return callback(er ? {error: er.message} : data);
    });
  } else if (cmd === &#x27;set-size&#x27;) {
    try {
      if (/cpu/i.test(req.size))
        req.size = os.cpus().length;
      else
        req.size = +req.size;
      master.setSize(req.size);
    } catch (er) {
      rsp.error = er.message;
    }

  } else if (cmd === &#x27;stop&#x27;) {
    try {
      master.stop();
    } catch (er) {
      rsp.error = er.message;
    }

  } else if (cmd === &#x27;restart&#x27;) {
    try {
      process.chdir(process.env.PWD);
    } catch (er) {
      // Ignore, things will probably go poorly, but we don&#x27;t want the master to
      // die even if the working directory becomes inaccessible, or the PWD,
      // probably a current link, becomes invalid.
    }
    try {
      master.restart();
    } catch (er) {
      rsp.error = er.message;
    }

  } else if (cmd === &#x27;disconnect&#x27;) {
    cluster.disconnect();

  } else if (cmd === &#x27;fork&#x27;) {
    rsp = null;
    var worker = cluster.fork();
    // worker emits its own &#x27;fork&#x27; _after_ s-c-c has augmented it
    worker.once(&#x27;fork&#x27;, function() {
      var rsp = {
        workerID: worker.id,
        processID: worker.process.pid,
        pst: worker.startTime,
      };
      callback(rsp);
    });

  } else if (cmd === &#x27;env-set&#x27;) {
    for (var k in req.env) {
      process.env[k] = req.env[k];
    }
    rsp = requestAllTargets(req, callback);

  } else if (cmd === &#x27;env-unset&#x27;) {
    for (var k in req.env) {
      delete process.env[req.env[k]];
    }
    rsp = requestAllTargets(req, callback);

  } else if (cmd === &#x27;tracing&#x27;) {
    var enabled = !!process.env.STRONGLOOP_TRACING;
    if (req.enabled &#x26;&#x26; !enabled) {
      process.env.STRONGLOOP_TRACING = 1;
    } else if (!req.enabled &#x26;&#x26; enabled) {
      delete process.env.STRONGLOOP_TRACING;
    } else {
      return;
    }

    try {
      master.restart();
    } catch (er) {
      rsp.error = er.message;
    }

  } else if (cmd === &#x27;signal&#x27;) {
    if (req.pid !== process.pid) {
     // Do nothing
    } else if (listenerCount(process, req.signame) &#x3e; 0) {
      // If there are any listeners for this signal, emit it on the
      // process object.
      process.emit(req.signame);
    } else {
      // If there are no listeners, use the default action.
      process.kill(process.pid, req.signame);
    }

  } else {
    // Pass any others off to the target
    rsp = requestOfTarget(req, rsp, callback);
  }

  if (callback &#x26;&#x26; rsp) {
    process.nextTick(callback.bind(null, rsp));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.runctl.start" id="apidoc.element.strong-supervisor.runctl.start">
        function <span class="apidocSignatureSpan">strong-supervisor.runctl.</span>start
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start(options) {
  var logger = options.logger;

  // XXX(sam) I don&#x27;t like this &#x27;last one wins&#x27; approach, but its impossible to
  // prevent the channel outliving sl-run under all conditions, this is the only
  // robust way I&#x27;ve found.
  try {
    fs.unlinkSync(options.channel);
  } catch (er) {
<span class="apidocCodeCommentSpan">    /* eslint no-empty:0 */
</span>    // Didn&#x27;t exist
  }

  server.listen(options.channel);

  server.on(&#x27;error&#x27;, function(er) {
    logger.error(&#x27;control channel failed to listen on `%s`: %s&#x27;,
                 options.channel, er);
    throw er;
  });

  master.on(&#x27;stop&#x27;, function() {
    server.close();
  });
  return server;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var logger = new Logger(process.stderr);

// Attach targeted control listener to cluster, for both master and workers.
require(&#x27;./targetctl&#x27;);

// Wrap watcher start, for use in master and workers.
function watcherStart(parentCtl) {
watcher.<span class="apidocCodeKeywordSpan">start</span>(parentCtl, cluster, control, module.exports);
}

if (cluster.isWorker) {
module.exports = {
  isWorker: true,
  isMaster: false,
  logger: logger,
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.start_command" id="apidoc.module.strong-supervisor.start_command">module strong-supervisor.start_command</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.start_command.start_command" id="apidoc.element.strong-supervisor.start_command.start_command">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>start_command
        <span class="apidocSignatureSpan">(pwd, argv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveArgs(pwd, argv) {
  var replacer = symlinkReplacer(pwd);
  var cwd = fs.realpathSync(pwd);
  var script = argv[2] || &#x27;.&#x27;;
  debug(&#x27;resolving CWD: %j, path: %j&#x27;, cwd, script);
  var app = resolvePath(cwd, script);
  var stat = app.stat;
  if (app.error) {
    return app;
  }

  if (stat.isFile()) {
    // given path was either foo/app.js that exists or foo/app that doesn&#x27;t
    // exist but which node would treat ass foo/app.js, so we&#x27;ll just find the
    // the package&#x27;s root directory and use that as the CWD when running the
    // specified script.
    return replacer(resolvePackageFromPath(app.cwd, app.path));
  }

  if (stat.isDirectory()) {
    // The given path is a directory, so now we want to find the nearest
    // package.json, use it as the CWD, and then perform an `npm start` like
    // script resolution.
    var absolutePath = path.resolve(app.cwd, app.path);
    var pkgApp = resolvePackageFromPath(absolutePath);

    // 1. try parsing scripts.start from the package.json
    var pkgStart = resolvePackageStart(pkgApp.cwd);
    if (!pkgStart.error) {
      return replacer(pkgStart);
    }

    // 2. try server.js, app.js, index.js**, then default module resolution
    // ** We explicitly check for index.js even though it will be checked by
    //    the node module resolver because we prefer it over the package&#x27;s main
    //    in cases where they are different.
    pkgApp.path = ifExists(pkgApp.cwd, &#x27;server.js&#x27;) ||
                  ifExists(pkgApp.cwd, &#x27;app.js&#x27;) ||
                  ifExists(pkgApp.cwd, &#x27;index.js&#x27;) ||
                  requireable(pkgApp.cwd, pkgApp.path);
    if (pkgApp.path) {
      return replacer(pkgApp);
    }
  }

  // The package.json doesn&#x27;t say how to run it, and node can&#x27;t decide.. time
  // to error out and let the user know they need to be more specific.
  return {error: Error(&#x27;app is not a file or a directory &#x27;)};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.start_command.fromStart" id="apidoc.element.strong-supervisor.start_command.fromStart">
        function <span class="apidocSignatureSpan">strong-supervisor.start_command.</span>fromStart
        <span class="apidocSignatureSpan">(cwd, script)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromStart(cwd, script) {
  var scriptRegexp = /^(\S+)((?:\s+-\S+)*)?(?:\s+(\S+))(\s.*)?$/;
  // use same default as npm
  var parts = scriptRegexp.exec(script || &#x27;node server.js&#x27;);
  // TODO: support extracting node options like --expose_gc and --harmony and
  // alternative executors, like coffee.
  // app.execPath = parts[1];
  // app.execArgs = parts[2];
  var resolved = ifExists(cwd, parts[3]) || requireable(cwd, parts[3]);
  debug(&#x27;script: [%j] %j =&#x3e; %j =&#x3e; %j via: &#x27;,
        cwd, script, parts[3], resolved,
        parts);
  if (!resolved) {
    return {error: Error(&#x27;Could not resolve start script &#x27; + script)};
  }
  return {cwd: cwd, path: resolved};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.start_command.resolveDir" id="apidoc.element.strong-supervisor.start_command.resolveDir">
        function <span class="apidocSignatureSpan">strong-supervisor.start_command.</span>resolveDir
        <span class="apidocSignatureSpan">(cwd, dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolveDir(cwd, dir) {
  var app = {
    cwd: path.resolve(cwd, dir),
    path: ifExists(cwd, &#x27;server.js&#x27;) || ifExists(cwd, &#x27;app.js&#x27;) || &#x27;.&#x27;,
    error: null,
  };
  return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.start_command.resolvePackageFromPath" id="apidoc.element.strong-supervisor.start_command.resolvePackageFromPath">
        function <span class="apidocSignatureSpan">strong-supervisor.start_command.</span>resolvePackageFromPath
        <span class="apidocSignatureSpan">(cwd, relative)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolvePackageFromPath(cwd, relative) {
  var absolute = path.resolve(cwd, relative || &#x27;&#x27;);
  var dir = path.dirname(absolute);
  var file = path.basename(absolute);
  if (!relative) {
    dir = absolute;
    file = &#x27;&#x27;;
  }
  // walk up the path until we find the package.json nearest to the app
  while (!ifExists(dir, &#x27;package.json&#x27;)) {
    file = path.join(path.basename(dir), file);
    // hit root, return the fallback to running the script in its directory
    if (dir === path.dirname(dir)) {
      file = path.basename(absolute);
      dir = path.dirname(absolute);
      break;
    }
    dir = path.dirname(dir);
  }
  return {cwd: dir, path: file, error: null};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.start_command.resolvePath" id="apidoc.element.strong-supervisor.start_command.resolvePath">
        function <span class="apidocSignatureSpan">strong-supervisor.start_command.</span>resolvePath
        <span class="apidocSignatureSpan">(cwd, script)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function resolvePath(cwd, script) {
  var app = {
    cwd: cwd,
    path: script,
  };

  try {
    app.stat = fs.statSync(path.resolve(app.cwd, app.path));
  } catch (er) {
    // app.path isn&#x27;t accessible, it may be a JS file given without the .js
    // extension, which is something that `node` and require() both honour.
    try {
      app.path = require.resolve(path.resolve(app.cwd, app.path));
      app.stat = fs.statSync(app.path);
    } catch (er) {
      // nope, it&#x27;s just plain not there, giving up.
      app.error = er;
    }
  }

  return app;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.tracer" id="apidoc.module.strong-supervisor.tracer">module strong-supervisor.tracer</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.tracer.tracer" id="apidoc.element.strong-supervisor.tracer.tracer">
        function <span class="apidocSignatureSpan">strong-supervisor.</span>tracer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tracer() {
  return TRACER;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.strong-supervisor.tracer.start" id="apidoc.element.strong-supervisor.tracer.start">
        function <span class="apidocSignatureSpan">strong-supervisor.tracer.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start() {
  assert(!TRACER);
  // This is delayed to allow process.env to be modified up until start time.
  options.accountKey = app.name();
  if (options.accountKey) {
    // This is delayed because requiring appmetrics causes it to monkey-patch,
    // which should not occur unless profiling or tracing is enabled.
    options.lrtime = require(&#x27;appmetrics&#x27;).lrtime;
    TRACER = require(&#x27;strong-trace&#x27;)(options);
  }
  return TRACER;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var logger = new Logger(process.stderr);

// Attach targeted control listener to cluster, for both master and workers.
require(&#x27;./targetctl&#x27;);

// Wrap watcher start, for use in master and workers.
function watcherStart(parentCtl) {
watcher.<span class="apidocCodeKeywordSpan">start</span>(parentCtl, cluster, control, module.exports);
}

if (cluster.isWorker) {
module.exports = {
  isWorker: true,
  isMaster: false,
  logger: logger,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.strong-supervisor.watcher" id="apidoc.module.strong-supervisor.watcher">module strong-supervisor.watcher</a></h1>


    <h2>
        <a href="#apidoc.element.strong-supervisor.watcher.start" id="apidoc.element.strong-supervisor.watcher.start">
        function <span class="apidocSignatureSpan">strong-supervisor.watcher.</span>start
        <span class="apidocSignatureSpan">(parentCtl, cluster, clusterControl, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (parentCtl, cluster, clusterControl, config) {
  var bus;

  // parentCtl is optional
  // cluster and strong-cluster-control are injected to allow mocking
  assert(cluster);
  assert(clusterControl);

  if (cluster.isMaster) {
    bus = new EventEmitter;

    clusterControl.on(&#x27;fork&#x27;, function(worker) {
      worker.on(&#x27;message&#x27;, function(msg) {
        var cmd = msg.cmd;
        msg = msg.msg;

        switch (cmd) {
          case &#x27;watcher:emit&#x27;:
            debug(&#x27;emit %j: %s&#x27;, msg.cmd, debug.json(msg));
            bus.emit(msg.cmd, msg, worker);
            break;
          case &#x27;watcher:send&#x27;:
            debug(&#x27;notify %j: %s&#x27;, msg.cmd, debug.json(msg));
            parentCtl.notify(msg);
            break;
          default:
            break;
        }
      });
    });
  }

  this._watchers.forEach(function(watcher) {
    var where = cluster.isWorker ? &#x27;:worker:&#x27; : &#x27;:master:&#x27;;

    var debug = require(&#x27;./debug&#x27;)(&#x27;watcher&#x27; + where + watcher.name);

    if (cluster.isWorker) {
      debug(&#x27;init&#x27;);
      watcher.worker({
        config: config,
        debug: debug,
        emit: function emit(msg) {
          debug(&#x27;emit %s&#x27;, debug.json(msg));
          cluster.worker.send({
            cmd: &#x27;watcher:emit&#x27;,
            msg: msg,
          });
        },
        send: function send(msg) {
          debug(&#x27;send %s&#x27;, debug.json(msg));
          cluster.worker.send({
            cmd: &#x27;watcher:send&#x27;,
            msg: msg,
          });
        },
      });
      return;
    }

    if (!parentCtl) {
      debug(&#x27;no parentctl&#x27;);
      return;
    }

    assert(cluster.isMaster);

    debug(&#x27;init: master? %j&#x27;, !!watcher.master);
    if (watcher.master) {
      watcher.master({
        config: config,
        debug: debug,
        emit: function emit(msg) {
          // This is master, so fake a Worker object.
          var worker = {
            id: 0,
            startTime: clusterControl.startTime,
            process: process,
          };
          debug(&#x27;emit %j: %s&#x27;, msg.cmd, debug.json(msg));
          bus.emit(msg.cmd, msg, worker);
        },
        on: function on(event, listener) {
          debug(&#x27;listen on %j&#x27;, event);
          bus.on(event, listener);
        },
        send: function notify(msg) {
          debug(&#x27;notify %s&#x27;, debug.json(msg));
          parentCtl.notify(msg);
        },
      });
    }

  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var logger = new Logger(process.stderr);

// Attach targeted control listener to cluster, for both master and workers.
require(&#x27;./targetctl&#x27;);

// Wrap watcher start, for use in master and workers.
function watcherStart(parentCtl) {
watcher.<span class="apidocCodeKeywordSpan">start</span>(parentCtl, cluster, control, module.exports);
}

if (cluster.isWorker) {
module.exports = {
  isWorker: true,
  isMaster: false,
  logger: logger,
...</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
